# 初始化，建立数据库
> 以共享单车为框架

```sql
drop DATABASE  if EXISTS  practiseOne; 
CREATE DATABASE practiseOne;
use practiseOne;

CREATE TABLE IF NOT EXISTS OriginDestination (
  id              INT  AUTO_INCREMENT NOT NULL, /*不为空值 唯一性约束*/ 
  number          VARCHAR(255),
  pickuptime      TIME,
  pickuplocationN DECIMAL(10, 7),
  pickuplocationE DECIMAL(10, 7),
  parkuptime      TIME,
  parkuplocationN DECIMAL(10, 7),
  parkuplocationE DECIMAL(10, 7),
  useduration     TIME DEFAULT NULL,
  PRIMARY KEY(id,number)
);

CREATE TABLE IF NOT EXISTS park (
  id              INT  AUTO_INCREMENT ,
  number          VARCHAR(255) DEFAULT 0,
  parkuptime      TIME,
  parkuplocationN DECIMAL(10, 7),
  parkuplocationE DECIMAL(10, 7),
  pickuptime      TIME,
  parkduration    TIME DEFAULT NULL,
  CONSTRAINT fk FOREIGN key(id,number) /*外键约束*/
  REFERENCES OriginDestination(id,number)
);

```
# 创建触发器

## 在插入、更新前进行检查，自动更新时间
```sql
CREATE TRIGGER insert_od
BEFORE INSERT
  ON OriginDestination
FOR EACH ROW
  SET NEW.useduration = timediff(NEW.parkuptime, NEW.pickuptime);

CREATE TRIGGER update_od
BEFORE UPDATE
  ON OriginDestination
FOR EACH ROW
  SET NEW.useduration = timediff(NEW.parkuptime , NEW.pickuptime)


CREATE TRIGGER insert_park
BEFORE INSERT
  ON park
FOR EACH ROW
  SET NEW.parkduration = timediff(NEW.pickuptime , NEW.parkuptime);

CREATE TRIGGER update_park
BEFORE UPDATE
  ON park
FOR EACH ROW
  SET NEW.parkduration = timediff(NEW.pickuptime , NEW.parkuptime);
```
<<<<<<< HEAD
## 在删除时，检查外建

```sql
delimiter /;    
create trigger tri_delete before delete on OriginDestination  
=======
> 在删除时，进行
delimiter //    
create trigger tri_dele345 5te before delete on OriginDestination  
>>>>>>> ba90b63883d8f69c2cdf69b2b114a2b5d6cc29bc
for each row  
begin  
     delete from park where id = old.id;  
end /; 
```

# 插入数据
```sql
INSERT INTO OriginDestination VALUE (NULL, '101', '01:00', 22.02, 30.01, '02:00', 23.01, 24.02, NULL);
INSERT INTO OriginDestination VALUE (NULL, '102', '02:01', 22.03, 32.01, '02:30', 23.01, 24.02, NULL);
INSERT INTO OriginDestination VALUE (NULL, '103', '03:02', 22.04, 34.01, '07:00', 23.01, 24.02, NULL);
INSERT INTO OriginDestination VALUE (NULL, '104', '03:03', 22.05, 35.01, '06:00', 23.01, 24.02, NULL);
INSERT INTO OriginDestination VALUE (NULL, '105', '04:04', 22.06, 37.01, '06:00', 23.01, 24.02, NULL);
INSERT INTO OriginDestination VALUE (NULL, '105', '05:05', 22.07, 35.01, '06:00', 23.01, 24.02, NULL);
INSERT INTO OriginDestination VALUE (NULL, '106', '01:06', 22.08, 38.01, '07:00', 23.01, 24.02, NULL);
INSERT INTO OriginDestination VALUE (NULL, '107', '01:07', 22.081, 39.01, '08:00', 23.01, 24.02, NULL);
INSERT INTO OriginDestination VALUE (NULL, '108', '01:08', 22.013, 32.01, '03:20', 23.01, 24.02, NULL);
```

# 测试外键约束
```sql
INSERT INTO park VALUE (NULL ,200,'3:00','23.03223','38.0323','05:00',NULL );

```
## 结果报错:

  Cannot add or update a child row: a foreign key constraint fails (`practiseone`.`park`, CONSTRAINT `fk` FOREIGN KEY (`id`, `number`) REFERENCES `origindestination` (`id`, `number`))

# 向park插入数据

```sql
INSERT INTO park VALUE (1 ,101,'3:00','25.03223','32.0323','05:00',NULL );
```
## 结果成功

  Query OK, 1 row affected (0.00 sec)

# 权限，用户管理
## grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权利。
```sql
grant select on  practiseOne.* to username@'%'
grant insert on  practiseOne.* to username@'%'
grant update on  practiseOne.* to username@'%'
grant delete on  practiseOne.* to username@'%'
```
或者，用一条 MySQL 命令来替代：  
```sql
grant select, insert, update, delete on  practiseOne.* to username@'%'
```

## grant 数据库开发人员，创建表、索引、视图、存储过程、函数等权限。
### 创建、修改、删除 MySQL 数据表结构权限。
```sql
grant create on  practiseOne.* to developer@'192.168.0.%';
grant alter on  practiseOne.* to developer@'192.168.0.%';
grant drop on  practiseOne.* to developer@'192.168.0.%';
```
### 操作 MySQL 外键权限。
```sql
grant references on  practiseOne.* to developer@'192.168.0.%';
```
### 操作 MySQL 临时表权限。
```sql
grant create temporary tables on  practiseOne.* to developer@'192.168.0.%';
```
### 操作 MySQL 索引权限。
```sql
grant index on  practiseOne.* to developer@'192.168.0.%';
```
### 操作 MySQL 视图、查看视图源代码 权限。
```sql
grant create view on  practiseOne.* to developer@'192.168.0.%';
grant show view on  practiseOne.* to developer@'192.168.0.%';
```
### 操作 MySQL 存储过程、函数 权限。
```sql
grant create routine on  practiseOne.* to developer@'192.168.0.%'; -- now, can show procedure status
grant alter routine on  practiseOne.* to developer@'192.168.0.%'; -- now, you can drop a procedure
grant execute on  practiseOne.* to developer@'192.168.0.%';
```
## 普通 DBA 管理某个 MySQL 数据库的权限。
```sql
grant all privileges on  practiseOne to dba@'localhost'
```
其中，关键字 privileges 可以省略。
## 高级 DBA 管理 MySQL 中所有数据库的权限。
```sql
grant all on *.* to dba@'localhost'
```
## MySQL grant 权限，分别可以作用在多个层次上。
1. grant 作用在整个 MySQL 服务器上：
```sql
grant select on *.* to dba@localhost; -- dba 可以查询 MySQL 中所有数据库中的表。
grant all on *.* to dba@localhost; -- dba 可以管理 MySQL 中的所有数据库
```
2. grant 作用在单个数据库上：
```sql
grant select on  practiseOne.* to dba@localhost; -- dba 可以查询  practiseOne 中的表。
```
3. grant 作用在单个数据表上：
```sql 
grant select, insert, update, delete on  practiseOne.orders to dba@localhost;
```
这里在给一个用户授权多张表时，可以多次执行以上语句。例如：
```sql
grant select(user_id,username) on smp.users to mo_user@'%' identified by '123345';
grant select on smp.mo_sms to mo_user@'%' identified by '123345';
```
4. grant 作用在表中的列上：
```sql
grant select(id, se, rank) on  practiseOne.apache_log to dba@localhost;
```
5. grant 作用在存储过程、函数上：
```sql
grant execute on procedure  practiseOne.pr_add to 'dba'@'localhost'
grant execute on function  practiseOne.fn_add to 'dba'@'localhost'
```
## 查看 MySQL 用户权限
查看当前用户（自己）权限：
```sql
show grants;
```
查看其他 MySQL 用户权限：
```sql
show grants for dba@localhost;
```
## 撤销已经赋予给 MySQL 用户权限的权限。
revoke 跟 grant 的语法差不多，只需要把关键字 to 换成 from 即可： 
```sql
grant all on *.* to dba@localhost;
revoke all on *.* from dba@localhost;
```
## MySQL grant、revoke 用户权限注意事项
1. grant, revoke 用户权限后，该用户只有重新连接 MySQL 数据库，权限才能生效。
2. 如果想让授权的用户，也可以将这些权限 grant 给其他用户，需要选项 grant option
```sql
grant select on  practiseOne.* to dba@localhost with grant option;
```
这个特性一般用不到。实际中，数据库权限最好由 DBA 来统一管理。
注意：创建完成后需要执行 FLUSH PRIVILEGES 语句。